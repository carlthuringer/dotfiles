#+TITLE: Emacs Configuration File
#+AUTHOR: Carl Thuringer
#+DESCRIPTION: A literate programming version of the Emacs Initialization Script, bootstrapped by the .emacs file.
#+PROPERTY:    header-args:elisp  :tangle ~/.emacs.d/init-main.el :results silent
#+PROPERTY:    header-args:shell  :tangle no

* Introduction

  This is my =.emacs= file, written in [[http://www.orgmode.org][literate style]] and ripped off
  from [[https://github.com/howardabrams/dot-files/blob/master/emacs.org][Howard Abrams]]. It was such a good idea that I figured I would
  do the same thing. Unless otherwise specified much of this file is
  cribbed from his Emacs config, and it would be tedious to attribute
  every swiped section. He's licensed it with (CC BY 3.0) so all I
  have to do is give him credit for the original.

  I also found [[http://aaronbedra.com/emacs.d/][Aaron Bedra's]] Emacs configuration. His website has a
  copyright but no apparent license. I will assume that emacs lisp
  statements copied for my personal use are fairly used.

  And I decided to start ALL OVER with emacs 27. Here goes.

** Emacs Executable

   Compile emacs from source! Yeah yeah!

   First I know we need some dependencies. I needed to install
   libxml2. I chose not to install texinfo this time because I don't
   know what it's for, but emacs can't compile without a better libxml
   than the one shipped with macos.

   #+begin_src shell
      brew install libxml2
   #+end_src

   Since brew doesnt' link libxml2, we have to pass some env variables
   to the commands when executing them. Did I mention I ran all of
   this stuff in eshell? Eshell doesn't support exports. Without
   figuring that out, I found that I could just jam everything in the
   single line.

   #+begin_src shell
     git clone https://git.savannah.gnu.org/git/emacs.git
     cd emacs
     LDFLAGS="-L/usr/local/opt/libxml2/lib" CPPFLAGS="-I/usr/local/opt/libxml2/include" PKG_CONFIG_PATH="/usr/local/opt/libxml2/lib/pkgconfig" ./configure
     LDFLAGS="-L/usr/local/opt/libxml2/lib" CPPFLAGS="-I/usr/local/opt/libxml2/include" PKG_CONFIG_PATH="/usr/local/opt/libxml2/lib/pkgconfig" make
     make install
   #+end_src

   This will produce an =Emacs.app= in the =nextstep= directory. Copy that
   to your =~/Applications= directory, and any other user's applications
   directories. Apparently it's bad style to put random apps in the
   root app dir.

   Now rename or remove the old =.emacs= and =.emacs.d/= and get ready to
   learn how fun it is to use vanilla emacs.

** Initialization...

   Set up the =init.el= and =early-init.el= files in the =~/.emacs.d= directory.

   #+NAME: init.el
   #+begin_src elisp :tangle no
     ;; Load our Literate Programming version of our Dot Emacs file from
     ;; our dotfiles repo.
     (load-file "~/.emacs.d/init-main.el")
     (server-start)
   #+end_src

   #+Name: early-init.el
   #+begin_src elisp :tangle no
     (setq package-quickstart t)
   #+end_src

   But how do we actually, you know, use this file?  First of all you
   have to find the property block at the top of the file and =C-c
   C-c= on it to evaluate and update all the local configuration, as
   it were. Then as you are working on it, you can evaluate source
   blocks by using =C-c C-c=. Once you are done, you can 'tangle' all
   the source blocks into a file by pressing =C-c C-v C-t=.

   But that's super annoying, it would be great to automate this
   process but for now I'm not bothering with that.


* Startup Improvements

  I want to get some of the clutter out of the way immediately when I
  start up emacs. So let's drop the toolbar, menu bar, scroll bars,
  and anything else that's annoying.

  #+BEGIN_SRC elisp
    (when (window-system)
      (tool-bar-mode -1)               ;; No Toolbars
      (menu-bar-mode -1)               ;; No Menu Bars
      (scroll-bar-mode -1) ;; No scrollbars
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1)))
  #+END_SRC

  And while we're modifying startup, let's kill the splash screen,
  scratch message, bell, and use of GUI dialog boxes. And then set our
  initial major mode to org.

  #+begin_src elisp
     (setq inhibit-splash-screen t
           initial-scratch-message nil
           visible-bell t              ;; Get rid of the beeps
           initial-major-mode 'org-mode ;; Default to org mode on startup
           use-dialog-box nil          ;; Don't show the dialog boxes.
     )
  #+end_src

* Base Editing Tweaks

  There are some baseline tweaks we can make to emacs that make it
  more pleasant to use.

  - show-paren-mode is great, and makes the editor light up matching
    parens.
  - y-or-n-p This is just so much easier than typing yes all the time.

  #+BEGIN_SRC elisp
    (show-paren-mode t)
    (defalias 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  I always use source control and so I never have any need of emacs
  backup files.

  #+BEGIN_SRC elisp
    (setq vc-make-backup-files nil
	  make-backup-files nil)
  #+END_SRC

  I do not want emacs to save customizations, let's redirect the
  custom file to dev null

  #+begin_src elisp
    (setq custom-file "/dev/null")
  #+end_src

  When reading =dir-locals=, trust the safe values and don't prompt me
  for them.

  #+begin_src elisp
    (setq enable-local-variables :safe)
  #+end_src

  I do like auto-save on lost focus.

   #+BEGIN_SRC elisp
     (defun ct/save-all ()
       "Save all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-function :after after-focus-change-function #'ct/save-all)
   #+END_SRC

   Strip whitespace on save.

   #+BEGIN_SRC elisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

   Normally emacs just ignores your selection and inserts wherever the
   cursor is when you start typing. This is too unintuitive for me, I
   expect to be able to replace sections I have selected when I yank
   into them.

   #+BEGIN_SRC elisp
     (delete-selection-mode t)
   #+END_SRC

   Aaron's config showed me this neat one. Empty line markers show you
   when the file is ending by putting some ticks in the left gutter.

   #+BEGIN_SRC elisp
     (setq-default indicate-empty-lines t)
     (when (not indicate-empty-lines)
       (toggle-indicate-empty-lines))
   #+END_SRC

   Globally set the indentation to 2 spaces, don't use tabs.

   #+BEGIN_SRC elisp
     (setq tab-width 2
           indent-tabs-mode nil)
   #+END_SRC

   Column number mode. Because sometimes you wanna know what column
   you're in.

   #+BEGIN_SRC elisp
     (setq column-number-mode t)
   #+END_SRC

   Set a nice dark theme.

   #+BEGIN_SRC elisp
     (load-theme 'misterioso t)
   #+END_SRC



** Key Bindings

   Some helpful key bindings to get us started.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<RET>") 'newline-and-indent)
     (global-set-key (kbd "C-;") 'comment-or-uncomment-region)
   #+END_SRC

** ANSI Color codes

   Lots of shell programs spam out ANSI color escape codes so they can
   look cool. In order to make this look OK in emacs, we have to do
   some work.

   #+BEGIN_SRC elisp
     (require 'ansi-color)
     (defun ct/colorize-compilation-buffer ()
       "Handle ANSI color codes in compilation buffers."
       (read-only-mode 'toggle)
       (ansi-color-apply-on-region (point-min) (point-max))
       (read-only-mode 'toggle))
     (add-hook 'compilation-filter-hook 'ct/colorize-compilation-buffer)
   #+END_SRC


* Basic UI

  This section covers UI customizations that make emacs easier to use.

  Make the cursor and region highlight way more
  visible.

  #+begin_src elisp
    (set-face-background 'cursor "DarkOrange3")
    (set-face-background 'region "MediumPurple2")
  #+end_src

* Package Manager

  To start off, let's use =package.el=

  #+BEGIN_SRC elisp
    (require 'package)
  #+END_SRC

  We're going to just use the built-in emacs package manager. I had
  been using jweigley's =use-package= for a little while, but every
  time I have to do something with it I have to look it up, and do
  mental transformation from whatever example I'm reading from into
  the particulars of the use-package format. First a list of packages.

  #+BEGIN_SRC elisp
    (defvar ct/packages '() "Carl's Installed Packages.")
    (set 'ct/packages '())
    (add-to-list 'ct/packages 'ace-window t)
    (add-to-list 'ct/packages 'add-node-modules-path t)
    (add-to-list 'ct/packages 'auto-package-update t)
    (add-to-list 'ct/packages 'apib-mode t)
    (add-to-list 'ct/packages 'beacon t)
    (add-to-list 'ct/packages 'company t)
    (add-to-list 'ct/packages 'counsel t)
    (add-to-list 'ct/packages 'exec-path-from-shell t)
    (add-to-list 'ct/packages 'flx t)
    (add-to-list 'ct/packages 'flycheck t)
    (add-to-list 'ct/packages 'inf-ruby t)
    (add-to-list 'ct/packages 'ivy t)
    (add-to-list 'ct/packages 'magit t)
    (add-to-list 'ct/packages 'plantuml-mode t)
    (add-to-list 'ct/packages 'projectile t)
    (add-to-list 'ct/packages 'rbenv t)
    (add-to-list 'ct/packages 'robe t)
    (add-to-list 'ct/packages 'rspec-mode t)
    (add-to-list 'ct/packages 'rubocopfmt t)
    (add-to-list 'ct/packages 'tide t)
    (add-to-list 'ct/packages 'org t)
    (add-to-list 'ct/packages 'which-key t)
    (add-to-list 'ct/packages 'yaml-mode t)
    ;;  Some packages need to be pinned. For example, I want org to always
    ;;  come form the org elpa, not the gnu one.

    (add-to-list 'package-pinned-packages
		 '("org" . "org") t)

    ;; Then set up the package manager.

    (add-to-list 'package-archives
		 '("org" . "https://orgmode.org/elpa/") t)
    (add-to-list 'package-archives
		 '("melpa-stable" . "https://stable.melpa.org/packages/") t)

    ;; Thank you, abedra.
    (defun abedra/packages-installed-p ()
      "Check if packages are installed."
      (cl-loop for pkg in ct/packages
	       when (not (package-installed-p pkg)) do (cl-return nil)
	       finally (cl-return t)))

    (unless (abedra/packages-installed-p)
      (message "%s" "Refreshing package database...")
      (package-refresh-contents)
      (dolist (pkg ct/packages)
	(when (not (package-installed-p pkg))
	  (package-install pkg))))
  #+END_SRC
** Auto Package Updates

   Automatically update packages and also refresh the package
   quickstart.

   #+BEGIN_SRC elisp
     (add-hook 'kill-emacs-hook (lambda ()
				  (progn (require 'auto-package-update)
					 (auto-package-update-maybe)
					 (package-quickstart-refresh))))

   #+END_SRC
** Exec Path

   This would normally be in the earlier environment setup but I have
   to wait until the packages are installed.

   #+begin_src elisp
     (when (memq window-system '(mac ns x))
       (exec-path-from-shell-initialize))
   #+end_src

* Fancy Package-enhanced UI

  This section involves package-based UI improvements.

** Ace-switcher

   [[https://github.com/abo-abo/ace-window][Ace]] provides clever shortcuts to switch windows, an improvement
   over constantly using =C-x o= to cycle around. I've already learned
   to use =C-x o= so let's remap that to ace-window.

   #+begin_src elisp
     (global-set-key (kbd "C-x o") 'ace-window)
     (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f))
   #+end_src


** Ivy

   Well, I was going to configure IDO to have vertical and cooler
   matching and... actually if I have to install packages for IDO to
   make it awesome, then I'm just going to switch to [[https://github.com/abo-abo/swiper][Ivy]]. ... Ivy is
   awesome. But to make it moreso I should still use the [[https://github.com/lewang/flx][flx]] package
   and set the fuzzy regex mode up.

   #+begin_src elisp
     (ivy-mode 1)
     (counsel-mode 1)
     (setq ivy-use-virtual-buffers t
	   enable-recursive-minibuffers t
	   ivy-re-builders-alist
	   '((swiper . ivy--regex-plus)
	     (t . ivy--regex-fuzzy))
	   )
     (global-set-key (kbd "\C-s") 'swiper)
     (global-set-key (kbd "\C-x d") 'counsel-dired)
   #+end_src

** Beacon

   I am always having a hard time finding my cursor after switching
   windows. [[https://github.com/Malabarba/beacon][Beacon]] makes this easier by flashing my cursor's landing
   position.

   #+begin_src elisp
     (beacon-mode 1)
   #+end_src

** Which Key

   I can't remember all these keystrokes. Remind me please.

   #+begin_src elisp
     (which-key-mode 1)
   #+end_src

* Org Mode


  I love org mode. It's so neat. Organize all the things.

  First of all, let's set up some simple behaviors that I want from my
  org mode. I want =auto-fill-mode= to be turned on.

  #+begin_src elisp
    (require 'org)

    (add-hook 'org-mode-hook 'auto-fill-mode)
  #+end_src

  Now that we have fill mode on, I want to make my newlines properly
  indented whenever I hit return. This turns out to be a side effect
  of a previous configuration that 'did something cool in source
  block'. Now =RET= usually calls =org-return= but if you remap it to
  =org-return-indent= then it will actually return and indent
  nicely. So the example from Howard Abrams neglected to mention
  that. Well, it's helpful to explore all this crap myself and figure
  out what's missing and actually spend time reading the documentation
  of each piece.

  #+begin_src elisp
    (org-defkey org-mode-map [remap org-return]
		(lambda () (interactive)
		  (if (org-in-src-block-p)
		      (org-return) ;; Return without indenting.
		    (org-return-indent)))) ;; Return with indenting
  #+end_src

  Had to read the =define-key= source. So actually KEY supports either
  a string or a vector of symbols and characters representing a
  sequence of keystrokes and events. It seems like it's possible to
  construct these with function calls like =(shift tab)=. You can also
  use =[remap foo]= and all mapping for =foo= will be replaced. And
  that's what finally worked.

  Another thing that's neat is hiding empahsis markers.

  #+begin_src elisp
    (setq org-hide-emphasis-markers t) ;; This hides =things= *like* /this/
  #+end_src

** Babel

   The second best part of org mode is its support for literate
   program, of which I am doing a lot right now because I am writing
   this file. Let's do some babel configuration to make things
   simpler.

   #+begin_src elisp
	  (setq org-src-fontify-natively t ;; Fontifies src blocks
		org-src-tab-acts-natively t ;; Make tab work even when we are not in the edit mode
		org-confirm-babel-evaluate nil) ;; Don't ask me every time if I want to eval.
	  (org-babel-do-load-languages
	   'org-babel-load-languages
	   '((emacs-lisp . t)
	     (shell . t)
	     (plantuml . t)))
   #+end_src

** GTD

   I use org files to get things done. Create the org directory if it
   doesn't exist.

   #+begin_src elisp
     (let* ((subdirs '("~/org")))
       (dolist (dir subdirs)
	 (when (not (file-exists-p dir))
	   (message "Make directory: %s" dir)
	   (make-directory dir))))
   #+end_src

   And this is the general org mode set up I like:

   #+begin_src elisp
     (setq
	org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)")
			    (sequence "|" "WAITING(w)" "CANCELED(c)"))
	org-agenda-files '("~/org/todo.org")
	org-default-notes-file "~/org/notes.org"
	org-directory "~/org"
	org-capture-templates
	'(("t" "Todo" entry
	   (file+headline "~/org/todo.org" "Tasks")
	   "* TODO %?")
	  ("n" "Notes" entry
	   (file "~/org/notes.org")
	   "* %u %?"))
	org-agenda-custom-commands
	'(("u" alltodo "Unscheduled"
	   ((org-agenda-skip-function
	     (lambda nil
	       (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp "\n]+")))
	    (org-agenda-overriding-header "Unscheduled TODO entries: ")))))
     (global-set-key (kbd "C-c c") 'org-capture)
     (global-set-key (kbd "C-c a") 'org-agenda)
     (org-defkey org-mode-map (kbd "C-c ,") 'org-time-stamp-inactive) ;; C-c . already puts in an active time stamp, this one lets me do an inactive one.
   #+end_src

* Programming

  This section handles programming-specific enhancements to emacs.

** User Interface

   When programming mode is on, show me line numbers.

   #+begin_src elisp
     (add-hook 'prog-mode-hook 'linum-mode)
   #+end_src
** Source Control

   I super duper like =magit= for all my git needs.

   #+begin_src elisp
     (require 'magit)
     (global-set-key (kbd "C-x g") 'magit-status)
   #+end_src

** Projects

   The =projectile= is pretty good for basic project navigation needs.

   #+begin_src elisp
     (projectile-mode +1)
     (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
     (setq projectile-switch-project-action 'projectile-commander ;; When we switch project, open the commander
	   projectile-completion-system 'ivy
	   )
     (def-projectile-commander-method ?s
       "Open a *eshell* buffer for the project."
       (projectile-run-eshell))
   #+end_src

** Flycheck

   Flycheck is a pluggable syntax checker and a replacement for
   flymake.

** Completion

   Autocompletion is super handy when working in big projects.

   #+begin_src elisp
     (add-hook 'typescript-mode-hook 'company-mode)
   #+end_src

** Typescript

   Getting Typescript to work really well takes some packages. I end
   up using =tide-mode=, =prettier-js-mode= and =flycheck=

   #+begin_src elisp
     (setq typescript-indent-level 2
	   prettier-js-args
	   '("--single-quote" "--trailing-comma" "all" "--no-semi"))

     (defun ct/setup-typescript ()
       "Sets up typescript."
       (progn
	 (require 'nvm)
	 (nvm-use-for (projectile-project-root))
	 (add-node-modules-path)
	 (tide-setup)
	 (tide-hl-identifier-mode)
	 (company-mode)
	 (flycheck-mode)
	 (prettier-js-mode)
	 (define-key typescript-mode-map (kbd "C-c , v") 'mocha-test-file)
	 ))

     (add-hook 'typescript-mode-hook 'ct/setup-typescript)
   #+end_src

** API Blueprint

   The [[https://apiblueprint.org/documentation/specification.html][Api Blueprint]] Format is designed to facilitate precise
   specification of restful apis.

   The =apib-mode= requires =drafter= to be installed.

   #+begin_src shell
     brew install drafter
   #+end_src

   #+begin_src elisp
     (autoload 'apib-mode "apib-mode" "Api Blueprint Mode" t)
     (add-to-list 'auto-mode-alist '("\\.apib\\'" . 'apib-mode))
   #+end_src

** Ruby

   A fun programming language. Robe mode enables some code lookup and
   documentation inline. You must have =pry= and =pry-doc= installed.

   #+begin_src elisp
     (autoload 'robe-mode "robe")
     (add-hook 'ruby-mode-hook 'robe-mode)
   #+end_src

   I want to have Rubocop checking and formatting my code.

   #+begin_src elisp
     (defun ct/ruby-flycheck-setup ()
       (let ((rubocop-path (concat (projectile-project-root) "bin/rubocop")))
	    (if (file-exists-p rubocop-path)
		(setq flycheck-ruby-rubocop-executable rubocop-path)
	      (setq flycheck-ruby-rubocop-executable nil))
       (flycheck-mode 1)))
     (add-hook 'ruby-mode-hook 'ct/ruby-flycheck-setup)
     (autoload 'rubocopfmt-mode "rubocopfmt")
     (add-hook 'ruby-mode-hook 'rubocopfmt-mode)
   #+end_src

   And let's add the robe company backend and company autocompletion

   #+begin_src elisp
     (eval-after-load 'company
       '(push 'company-robe company-backends))
     (add-hook 'ruby-mode-hook 'company-mode)
   #+end_src

** Plantuml

   Let's set up plantuml so that we can use it reliably in emacs.

   #+begin_src elisp
     (setq plantuml-default-exec-mode 'jar
	   plantuml-jar-path "/usr/local/opt/plantuml/libexec/plantuml.jar"
	   org-plantuml-jar-path plantuml-jar-path)
   #+end_src

* Writing


** Markdown

   When writing in markdown mode, set auto-fill-mode so that my lines
   get automatically wrapped.

   #+begin_src elisp
     (add-hook 'markdown-mode-hook 'auto-fill-mode)
   #+end_src
