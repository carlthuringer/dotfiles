To install this configuration invoke =org-babel-tangle= with =C-x C-v C-t=

* Intro
  Having been there and back again when it comes to various Emacs
  distributions and configuration methods I'm coming back to literate
  configuration. It feels as though I have atrophied and am not
  utilizing my editor fully, especially not org mode.

  Well, I can edit this a bit later. For now, on to the configuration.

  
** How to do literate configuration?
   It's entirely done with tangle and source blocks. 

   The other trick to doing literate is to use =noweb= to organize
   code snippets into the target file, so that you aren't forced to
   organize your document based on the structure of the eventual code
   file.
   #+begin_example
     ,#+begin_src elisp :tangle ~/.config/emacs/init.el :mkdirp yes :noweb yes
       <<bootstrapping>>
     ,#+end_src
   #+end_example
** Noweb Header Arg
   You can make all source blocks in a heading tangle together by
   placing a property in the Properties drawer. Invoke =C-c C-x p=
   and enter:
   #+begin_example
     :header-args: :noweb-ref reference-name
   #+end_example
** What version of Emacs are we targeting?
I've upgraded to Emacs 29, which is the not-quite-bleeding edge, in order to gain access to built-in tree-sitter and eglot.

* Disable packages on startup
  First of all, let's disable loading all available packages at
  startup. This has to be done in the early-init file so we're making
  an exception to the =noweb-ref= so that it doesn't get blended into
  the main init file.
  # PROBLEM: If I do this, then none of my packages are on the load
  # path, so it's impossible to proceed and use other packages.
  Solution: Use straight.el, and it tells me to do this.

  #+begin_src elisp :tangle ~/.config/emacs/early-init.el :mkdirp yes
    (setq package-enable-at-startup nil)

    ;; Some things from emacs bedrock!
    ;; https://git.sh.ht/~ashton314/emacs-bedrock

    ;; Startup speed, annoyance suppression
    (setq gc-cons-threshold 10000000)
    (setq byte-compile-warnings '(not obsolete))
    (setq warning-suppress-log-types '((comp) (bytecomp)))
    (setq native-comp-async-report-warnings-errors 'silent)

    ;; Silence stupid startup message
    (setq inhibit-startup-echo-area-message (user-login-name))

    ;; Default frame configuration: full screen, good-looking title bar on macOS
    (setq frame-resize-pixelwise t)
    (tool-bar-mode -1)                      ; All these tools are in the menu-bar anyway
    (setq default-frame-alist '((fullscreen . maximized)

                                ;; You can turn off scroll bars by uncommenting these lines:
                                ;; (vertical-scroll-bars . nil)
                                ;; (horizontal-scroll-bars . nil)

                                ;; Setting the face in here prevents flashes of
                                ;; color as the theme gets activated
                                (background-color . "#000000")
                                (ns-appearance . dark)
                                (ns-transparent-titlebar . t)))
          
  #+end_src

* Scaffolding the init file
  Here's the layout for the init file

  #+begin_src elisp :tangle ~/.config/emacs/init.el :mkdirp yes :noweb yes :no-export yes
    <<initialization-performance>>

    <<bootstrapping>>

    <<user-interface>>

    <<programming-general>>

    <<org-mode>>

    <<docker>>

    <<ledger>>

    <<documentation>>

    <<database>>

    <<kubernetes>>
  #+end_src
  
* Initialization Performance Tuning
  :PROPERTIES:
  :header-args: :noweb-ref initialization-performance
  :END:
  These are some arcana picked up from other initializations that
  help with startup speed.

  Let's set up a little scaffolding:
  #+begin_src elisp :noweb yes :no-export yes
    <<file-name-handler-alist-old>>

    (setq
     <<performance-tuning-before>>
     )

    (add-hook 'after-init-hook
	      `(lambda ()
		 (setq
		  <<performance-tuning-after>>
		  )
		 (garbage-collect)) t)
  #+end_src
   
** =file-name-handler-alist=
   At initialization, this variable holds several complex regular
   expressions that are evaluated on all file loading to determine if
   they should go through a special handler function. During
   initialization we don't want this so we first define a variable
   and store it.
   #+begin_src elisp :noweb-ref file-name-handler-alist-old
     (defvar file-name-handler-alist-old file-name-handler-alist)
   #+end_src

   Then set it to nil before init
   #+begin_src elisp :noweb-ref performance-tuning-before
     file-name-handler-alist nil
   #+end_src

   And set it back after init
   #+begin_src elisp :noweb-ref performance-tuning-after
     file-name-handler-alist file-name-handler-alist-old
   #+end_src
** =read-process-output-max=
   This affects how many bites to read from the subprocess in a single
   chunk. It defaults to 4kB, so let's up it to 1mB because we have a
   big computer.
   #+begin_src elisp :noweb-ref performance-tuning-after
     read-process-output-max (* 1024 1024)
   #+end_src
   
* Bootstrapping
  :PROPERTIES:
  :header-args: :noweb-ref bootstrapping
  :END:
  I will be using one fancy package management framework, the
  excellent [[https://github.com/jwiegley/use-package][use-package]] from [[https://github.com/jwiegley][John Wiegley]]. I'm also going to borrow
  some of his example emacs initialization from his [[https://github.com/jwiegley/dot-emacs][dot-emacs]]
  repository, but only a bit.

  UPDATE: use-package isn't really a package manager, it's a package
  configurere, and as such it isn't very good at complicated package
  installation concerns. So we'll defer package management to [[https://github.com/raxod502/straight.el#integration-with-use-package-1][straight.el]].
   
** Bootstrap =straight.el=
   TODO: The latest emacs master renamed
   =comp-deferred-compilation-deny-list= to
   =native-comp-deferred-compilation-deny-list=, so straight is
   bugging out. To fix it, let's first alias that back. Maybe soon it
   will be fixed: https://github.com/raxod502/straight.el/issues/757

   I actually disabled this now, let's see if it still work

   #+begin_src elisp :noweb-ref nil
     (setq native-comp-deferred-compilation-deny-list nil)
   #+end_src

   #+begin_src elisp
     (defvar bootstrap-version)
     (setq straight-repository-branch "develop")
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
   #+end_src

** Install use-package if it isn't installed.
   #+begin_src elisp
     (straight-use-package 'use-package)
     (require 'bind-key)
   #+end_src

** Automatically install packages mentioned by use-package
   #+begin_src elisp
		 (setq straight-use-package-by-default t)
		 (setq use-package-always-defer t)
   #+end_src

** Ensure that our exec path is configured
   Emacs looks in the =exec-path= for binaries when invoking a shell
   command. For better or worse we do still do much of our work with a
   real shell, and not within the confines of emacs, so as a shortcut
   we can configure the exec-path by using this helpful package, which
   spawns a shell process and dumps the path.
   #+begin_src elisp :noweb yes :no-export yes
     (use-package exec-path-from-shell
       :demand t
       :config
       (exec-path-from-shell-initialize)
       <<exec-path-from-shell-config>>
       )
   #+end_src
   
** Copy some environment variables, if they are present
   There are some secrets that I configure in my =.zshrc= that I
   sometimes need in my eshell.
   #+begin_src elisp :noweb-ref exec-path-from-shell-config
     (exec-path-from-shell-copy-envs '("NIX_PATH" "GITHUB_USER" "GITHUB_PACKAGE_PULL_TOKEN" "CFLAGS" "FASTLY_API_KEY"))
   #+end_src

** Make sure that Homebrew info directory is loaded if present
Homebrew keeps info files in =/opt/homebrew/share/info=. They won't show
up in emacs' info browser unless they're added to the =Info-directory-list=
#+begin_src elisp
  (add-to-list 'Info-directory-list "/opt/homebrew/share/info")
#+end_src
* General User Interface
  :PROPERTIES:
  :header-args: :noweb-ref user-interface
  :END:
  Emacs' user interface is a bit dated looking and distracting, so I
  apply some small modifications to clean things up.
  
** Disable =scroll-bar-mode=
   This specifies whether to have any scroll bars.
   #+begin_src elisp
     (scroll-bar-mode 0)
   #+end_src
** Set =visible-bell=
   Instead of issuing a system beep, use visible bell, which flashes
   the frame when a bell occurs. Test by smashing =C-g=
   #+begin_src elisp
     (setq visible-bell 1)
   #+end_src

** Font: Fira Code
   Pretty much my favorite font for programming right now. Has the
   most ligatures and is quite well supported across platforms.
   #+begin_src elisp
     (use-package faces
       :straight nil
       :config
       ;; Set my preferred font.
       (set-face-font 'default "Fira Code-14"))
   #+end_src

   To enable ligatures on the latest emacs, we have to use the
   ligature.el package
   #+begin_src elisp
     (use-package ligature
       :straight '(ligature :type git :host github :repo "mickeynp/ligature.el")
       :demand t
       :config
       (ligature-set-ligatures 'prog-mode '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
                                            ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
                                            "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
                                            "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
                                            "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
                                            "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
                                            "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
                                            "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
                                            "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
                                            "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"))
     
       (global-ligature-mode 't))
   #+end_src

** Disable the Customize interface updating my emacs file
   I like to know how and why various things are being set in my emacs
   files and therefore avoid the =customize-*= stuff that
   automatically updates my emacs init file.
   #+begin_src elisp
     (setq-default custom-file null-device)
   #+end_src

** Pulse
   In order to find the cursor whenever moving between regions, use
   the built-in pulse mode. 
   #+begin_src elisp
     (use-package pulse
       :straight nil
       :demand t
       :config
       (defun pulse-line (&rest _)
         "Pulse the current line."
         (pulse-momentary-highlight-one-line (point)))
       (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
         (advice-add command :after #'pulse-line)))
   #+end_src

** =diminish=
   Allows us to hide minor modes cluttering up our mode line.
   #+begin_src elisp
     (use-package diminish :demand t)
   #+end_src
   
** which-key help me remember which key to press
   #+begin_src elisp
     (use-package which-key
       :diminish
       :demand t
       :commands which-key-mode
       :config
       (which-key-mode))
   #+end_src
  
** Enable recursive minibuffers
Some fancy things like to show a minibuffer while you're in a minibuffer. Usually this is fine.
#+begin_src elisp
  (use-package emacs
    :straight nil
    :init
    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src
** Completion Framework
*** Vertico autocompletion
Apparently Selectrum has [[https://github.com/minad/vertico/wiki/Migrating-from-Selectrum-to-Vertico][been replaced by vertico]], so I can finally fix ripgrep searches.
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode)

    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    ;; (setq vertico-cycle t)
    )
#+end_src

Save history across Emacs restarts, which Vertico uses to sort entries.
#+begin_src elisp
  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :straight nil
    :init
    (savehist-mode))
#+end_src

An alternative filtering system [[https://github.com/oantolin/orderless#selectrum][orderless]].
#+begin_src elisp
  (use-package orderless
    :demand t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

Make sorting more prescient
#+begin_src elisp
  (use-package selectrum-prescient
    :demand t
    :after selectrum
    :custom
    (prescient-save-file "~/.config/emacs/prescient")
    :config
    (selectrum-prescient-mode +1)
    (prescient-persist-mode +1))
#+end_src
*** Consult
Well this is a whole thingy. [[https://github.com/minad/consult][Consult]]
#+begin_src elisp
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;;;; 1. project.el (the default)
    (setq consult-project-function #'consult--default-project-function)
    ;;;; 2. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 3. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    ;;;; 4. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 5. No project support
    ;; (setq consult-project-function nil)
  )
#+end_src

#+RESULTS:
: consult-history

*** [[https://github.com/minad/marginalia][Marginalia]]
#+begin_src elisp
  ;; Enable richer annotations using the Marginalia package
  (use-package marginalia
    ;; Either bind `marginalia-cycle` globally or only in the minibuffer
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
#+end_src
*** [[https://github.com/oantolin/embark/][Embark]]
#+begin_quote
Embark makes it easy to choose a command to run based on what is near
point, both during a minibuffer completion session (in a way familiar
to Helm or Counsel users) and in normal buffers.
#+end_quote

#+begin_src elisp
  (use-package embark
    :ensure t

    :bind
    (("C-<return>" . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+RESULTS:
| consult-preview-at-point-mode | embark-consult--upgrade-markers |

** Disable Auto-save and tempfiles
   #+begin_src elisp
     (use-package files
       :straight nil
       :custom (backup-directory-alist `((".*" . ,temporary-file-directory)))
       (auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
       (make-backup-files nil))
   #+end_src

** Silencing noisy warnings
#+begin_src elisp
  (use-package warnings
    :straight nil
    :custom (warning-minimum-level :error))
#+end_src

** Theme
Switching to the built-in modus themes
#+begin_src elisp
  (use-package solarized-theme
    :demand t
    :custom
    (custom-safe-themes t)
    :config
    (load-theme 'solarized-selenized-light t))
#+end_src

** Mode Line
Smart mode line
#+begin_src elisp
  (use-package smart-mode-line
    :demand t
    :config (sml/setup))
#+end_src

** Display Battery and Time
#+begin_src elisp
  (use-package battery
    :straight nil
    :demand t
    :config (display-battery-mode 1))

  (use-package time
    :straight nil
    :demand t
    :config (display-time-mode 1))
#+end_src
** Eshell
In order to use sudo/tramp in eshell nicely, you must update the eshell modules list which doesn't include them by default.
#+begin_src elisp
  (use-package esh-module
    :straight nil
    :demand t
    :custom
    (password-cache t)
    (password-cache-expiry 300)
    :config
    (add-to-list 'eshell-modules-list 'eshell-tramp))
#+end_src
** [[https://github.com/abo-abo/avy][Avy (jump to characters)]]
Helps you navigate around a big screen of letters!
#+begin_src elisp
  (use-package avy
    :demand t
    :bind ("C-." . avy-goto-char-timer)
    :custom
    (avy-timeout-seconds 0.3))
#+end_src

** Expand Region
This is a handy script that lets you expand the selection region at the point by pressing =C-==
#+begin_src elisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
    
#+end_src
** Unfill paragraph
- ref :: https://www.emacswiki.org/emacs/UnfillParagraph

  #+begin_src elisp
    ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph    
    (defun unfill-paragraph (&optional region)
      "Takes a multi-line paragraph and makes it into a single line of text."
      (interactive (progn (barf-if-buffer-read-only) '(t)))
      (let ((fill-column (point-max))
            ;; This would override `fill-column' if it's an integer.
            (emacs-lisp-docstring-fill-column t))
        (fill-paragraph nil region)))
    (global-set-key "\M-Q" 'unfill-paragraph)
  #+end_src
** Text Scaling
You know sometimes you want to adjust the default text scaling, for reasons. Let's use =C-+= and =C-_= as commands.
#+begin_src elisp
  (use-package default-text-scale :demand t :diminish t :config (default-text-scale-mode 1))
#+end_src
** Dired
Using dired for file management is super great, but it's usually got too much detail. So let's hide details by default.
#+begin_src elisp
  (use-package dired
    :straight nil
    :preface
    (defun my/dired-details-setup () "Show less information in dired buffers"
           (dired-hide-details-mode 1))
    :custom
    (dired-hide-details-hide-symlink-targets nil)
    :hook
    (dired-mode . my/dired-details-setup)
    )
#+end_src
** Typing
I got a new keyboard and it's pretty hard to type on. I need practice.
#+begin_src elisp
  (use-package speed-type)
#+end_src

To use this, use =M-x speed-type-buffer= or something similar to initiate a typing test in the current buffer.
** Cleaning up open file watches
Emacs on Macos hits the ulimit of 1024 a lot. Here we define a function from the future that allows us to remove watches from the =file-notify-descriptors= list.
#+begin_src elisp
  (defun file-notify-rm-all-watches ()
    "Remove all existing file notification watches from Emacs."
    (interactive)
    (maphash
     (lambda (key _value)
       (file-notify-rm-watch key))
     file-notify-descriptors))
#+end_src
** Disable Lockfiles
I don't really do a multi-user thing and these lockfiles screw up =terraform-ls=.
#+begin_src elisp
  (setq create-lockfiles nil)
#+end_src
** Org-Present
Use org-present to give presentations straight from org mode
#+begin_src elisp
  (defun my/org-present-start ()

    ;; Tweak font sizes
    (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
                                       (header-line (:height 4.0) variable-pitch)
                                       (org-document-title (:height 1.75) org-document-title)
                                       (org-code (:height 1.55) org-code)
                                       (org-verbatim (:height 1.55) org-verbatim)
                                       (org-block (:height 1.25) org-block)
                                       (org-block-begin-line (:height 0.7) org-block)))

    ;;Create empty header space
    (setq header-line-format " ")

    ;; Center the presentation and wrap lines
    (visual-fill-column-mode 1)
    (visual-line-mode 1)

    (load-theme 'solarized-selenized-dark)

    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

    )

  (defun my/org-present-end ()
    ;; reset fonts
    (setq-local face-remapping-alist '(((default variable-pitch default))))

    (setq header-line-format nil)

    (visual-fill-column-mode 0)
    (visual-line-mode 0)
    (load-theme 'solarized-selenized-light)
    )

  (defun my/org-present-prepare-slide (buffer-name heading)
    ;; Show only top-level headlines
    (org-overview)
    ;; Unfold the current entry
    (org-show-entry)
    ;; Show only direct subheadings of the slide but don't expand them
    (org-show-children))

  (use-package visual-fill-column
    :custom
    (visual-fill-column-width 110)
    (visual-fill-column-center-text t))
  (use-package org-present
    :after visual-fill-column
    :hook ((org-present-mode . my/org-present-start)
           (org-present-mode-quit . my/org-present-end))
    :init
    (add-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide))
#+end_src
** [[https://emacs-tree-sitter.github.io/installation/][Tree Sitter Syntax Highlighting]]
It's a faster, better way of highlighting instead of font-lock whatever nonsense regexps.

Tree sitter is built into emacs 29.

In order to activate you must hook =tree-sitter-hl-mode= on any major modes for which you want it active
#+begin_src elisp
  (use-package tree-sitter
    :straight nil
    :hook ((go-mode
            js-mode
            nix-mode
            terraform-mode
            typescript-mode
            web-mode
            yaml-mode
            ruby-mode) . tree-sitter-hl-mode))
  (use-package tree-sitter-langs :after tree-sitter)
#+end_src

In order to actually install language libraries when they are not shipped with major modes (often not) you can install [[https://github.com/emacs-tree-sitter/tree-sitter-langs][tree-sitter-langs]] which offers a function =tree-sitter-langs-install-grammars= for downloading the latest grammars. It does not, however install them properly, so we need to do a little extra work... Maybe someday in elisp.
#+begin_src elisp
  (use-package tree-sitter-langs :commands tree-sitter-langs-install-grammars)
#+end_src

With this installed, you must then follow the advice from [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][MasteringEmacs: How to get started with tree sitter]]

#+begin_quote
The names of the files are <LANGUAGE>.so (or with your platform’s equivalent extension) which is not in keeping with the expected naming style in Emacs. You must first rename them so they’re named libtree-sitter-<LANGUAGE>.so. This is as good a time as any to learn how to bulk rename them with Emacs’s M-x dired and the editable dired buffers feature. 
#+end_quote

Editable dired is achieved by =C-x C-q=. The files must be moved to the emacs config directory, which is =~/.config/emacs/tree-sitter=

Finally, there's a bit to actually supporting tree-sitter... that is, if a major mode doesn't already upgrade itself to the =major-ts-mode= then it won't just... work. You would have to update the =auto-mode-alist= entry for that mode, which comes from... somewhere? Actually it's a lot easier to just customize =major-mode-remap-alist=.

First find all the modes with =C-h a= and =-ts-mode$= for the apropos search. That gives you a list of supported tree sitter modes given your current set of packages. Probably.

Then update the following snippet to add mappings from the non-ts mode to the ts-mode which will occur transparently.

#+begin_src elisp
  (use-package files
    :straight nil
    :init
    (setq major-mode-remap-alist
          '(
            (bash-mode . bash-ts-mode)
            (c++-mode . c++-ts-mode)
            (c-or-c++-mode . c-or-c++-ts-mode)
            (cmake-mode . cmake-ts-mode)
            (csharp-mode . csharp-ts-mode)
            (css-mode . css-ts-mode)
            (dockerfile-mode . dockerfile-ts-mode)
            (go-mod-mode . go-mod-ts-mode)
            (go-mode . go-ts-mode)
            (java-mode . java-ts-mode)
            (js-mode . js-ts-mode)
            (js2-mode . js-ts-mode)
            (json-mode . json-ts-mode)
            (python-mode . python-ts-mode)
            (ruby-mode . ruby-ts-mode)
            (rust-mode . rust-ts-mode)
            (toml-mode . toml-ts-mode)
            (tsx-mode . tsx-ts-mode)
            (typescript-mode . typescript-ts-mode)
            (yaml-mode . yaml-ts-mode))))
#+end_src
** [[https://github.com/zerolfx/copilot.el#installation][Github Copilot]]
Yes, the evil AI is even in my emacs configuration.

#+begin_src elisp
  (use-package copilot
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :bind (:map copilot-completion-map
                (("<tab>" . 'copilot-accept-completion)
                 ("TAB" . 'copilot-accept-completion))))

#+end_src
** Safe local variables
Sometimes I use =.dir-locals.el= to set local variable values for a given project. This is a list of things which are safe to set so Emacs doesn't constantly get mad.
#+begin_src elisp
  (use-package files
    :straight nil
    :custom
    (safe-local-variable-values
      '((eval setq jsonnet-library-search-directories
         (list
          (concat
           (car
            (dir-locals-find-file "./"))
           "lib"))))))
#+end_src
* Programming
  :PROPERTIES:
  :header-args: :noweb-ref programming-general
  :END:
All programming mode enhancements.
** Minor Tweaks
Show Paren mode is always useful and built-in.
#+begin_src elisp
  (use-package paren
    :straight nil
    :hook ((prog-mode terraform-mode) . show-paren-mode))
#+end_src

And trim whitespace
#+begin_src elisp
  (use-package ws-butler
    :hook
    ((prog-mode
     markdown-mode
     yaml-mode
     yaml-ts-mode
     terraform-mode
     ) . ws-butler-mode))
#+end_src

** Projectile
   An eminently useful way to navigate git-based project directories.
   #+begin_src elisp :noweb-ref nil
     (use-package projectile
       :diminish
       :init (projectile-mode +1)
       :bind-keymap ("C-c p" . projectile-command-map)
       :custom
       (projectile-enable-caching t))
   #+end_src

   And let's get the counsel integration support in.
   #+begin_src elisp :noweb-ref nil
     (use-package counsel-projectile
       :diminish
       :after projectile
       :init (counsel-projectile-mode 1))
   #+end_src

*** Or project.el?
Project is built into emacs! Why are we using projectile?
#+begin_src elisp
  (use-package project
    :demand t)
#+end_src

** Magit the magic git porcelain
   Really there are few things more awesome than the power of Magit in
   experienced hands. It's like vim for git repositories.
   #+begin_src elisp
     (use-package magit
       :bind (("C-x g" . magit-status)))
   #+end_src

*** Magit Forge
In my quest to increase my productivity, what if I could do all the github PR work directly in magit? Let's find out.
#+begin_src elisp
  (use-package forge
    :after magit)
#+end_src

We also need sqlite until *emacs 29*
#+begin_src elisp
  (use-package sqlite3)
#+end_src

** Company the autocompleter
Company-mode is an autocompletion framework used happily by many other modes. http://company-mode.github.io/ We can pretty much turn it on for all programming modes, so that's what we will do.
#+begin_src elisp
  (use-package company
    :demand t
    :diminish
    :config
    (global-company-mode +1))

  (use-package company-box
    :diminish
    :hook (company-mode . company-box-mode))
#+end_src

** Flycheck the better checker
Flymake is built into emacs, but flycheck is better
#+begin_src elisp
  (use-package flycheck)
#+end_src

** Yasnippet
A template expansion mode for emacs [[http://joaotavora.github.io/yasnippet/]]

I kept running into gross issues working with go-mode, since it seems
to want to use yasnippet when company completes things...
#+begin_src elisp
  (use-package yasnippet
    :hook ((prog-mode terraform-mode) . yas-minor-mode)
    )
#+end_src

** [[https://github.com/joaotavora/eglot][Eglot IDE features]]
Upgraded to emacs 29, eglot built-in now
#+begin_src elisp
  (use-package eglot
    :ensure t
    :commands (eglot eglot-ensure)
    :hook
    ((dockerfile-mode
      go-mode
      go-ts-mode
      js-mode
      nix-mode
      ruby-mode
      terraform-mode
      typescript-ts-mode
      yaml-mode
      jsonnet-mode) . eglot-ensure)
    ((terraform-mode
      typescript-ts-mode) . eglot-format-buffer-on-save)
      
    :config
    (add-to-list 'eglot-server-programs
                 '(terraform-mode . ("terraform-ls" "serve")))
    (add-to-list 'eglot-server-programs
                 '(jsonnet-mode . ("jsonnet-language-server" "-t")))
    (add-hook 'eglot-managed-mode-hook (lambda () (remove-hook 'flymake-diagnostic-functions 'eglot-flymake-backend)))
    :init
    (defun eglot-format-buffer-on-save ()
      (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
    (setq eglot-autoshutdown t))

#+end_src
** YAML
#+begin_src elisp
  (use-package yaml-mode)
#+end_src

** Dockerfiles
#+begin_src elisp
  (use-package dockerfile-mode)
#+end_src
** Ruby
   All my favorite ruby programming configuration.
   And by the way, ruby-mode annoyingly inserts this magic comment. STOP
    #+begin_src elisp
      (use-package ruby-mode
        :straight nil
        :custom
        (ruby-insert-encoding-magic-comment nil))
    #+end_src
*** Ruby Test Mode
This is even better than rspec mode for testing ruby, because it works for rspec and minitest.
#+begin_src elisp
  (use-package ruby-test-mode
    :hook (ruby-mode))
#+end_src
** HAML
#+begin_src elisp
  (use-package haml-mode)
#+end_src
** Javascript
#+begin_src elisp
  (use-package js
    :straight nil
    :custom
    (js-indent-level 2)
    (indent-tabs-mode nil))
#+end_src
Prettier formatting for javascript
#+begin_src elisp
  (use-package prettier
    :hook ((typescript-mode
            typescript-ts-mode
            js-mode
            js2-mode
            tsx-ts-mode) . prettier-mode)
  )
#+end_src

** Typescript
#+begin_src elisp
  (use-package typescript-mode
    :mode "\\.tsx?\\'"
    :custom
    (typescript-indent-level 2))
#+end_src

And for tsx files, =web-mode=
#+begin_src elisp
  (use-package web-mode :mode "\\.((j|t)sx?|html)\\'"
    :custom
    (web-mode-markup-indent-offset 2)
    (web-mode-css-indent-offset 2)
    (web-mode-code-indent-offset 2)
    )
#+end_src
** Golang
#+begin_src elisp
  (use-package go-mode
    :config (add-hook 'before-save-hook #'gofmt-before-save)
    :custom
    (tab-width 2)
    (compile-command "go build -v && go test -v && go vet"))

  (use-package gotest
    :after go-mode
    :bind (:map go-mode-map
                (("C-c C-t n" . go-test-current-test)
                 ("C-c C-t f" . go-test-current-file)
                 ("C-c C-t a" . go-test-current-project))
                )
    )

  (use-package gorepl-mode
    :hook go-mode)
#+end_src

And to be even cooler, add it to =org-babel= with =ob-go=
#+begin_src elisp
  (use-package ob-go)
#+end_src

#+begin_src elisp :noweb-ref org-babel-load-languages
  (go . t)
#+end_src
** Terraform HCL
Often I have to work in Terraform files
#+begin_src elisp
  (use-package terraform-mode)
#+end_src

*** Installing the terraform-ls server
Prerequisite brew or linuxbrew
#+begin_src sh :session *shell install-terraform-ls* :noweb-ref nil
  brew install hashicorp/tap/terraform-ls
#+end_src

** Rest Client
This is a portable, useful way to use emacs as a REST http client.
#+begin_src elisp
  (use-package restclient)
  (use-package ob-restclient :after org)
  (use-package cl-lib)
  (use-package jq-mode
    :demand t)
#+end_src

#+begin_src elisp :noweb-ref org-babel-load-languages
  (restclient . t)
#+end_src
** NixOS
The [[https://nixos.org/manual/nix/stable/][nix package manager]] and NixOS is a method for installing and
managing environments of software programs, building, and configuring
them. It can be seen as an alternative to homebrew or other package
management solutions. It uses a declarative language for describing
environments or system configurations.

#+begin_src elisp
  (use-package nix-mode)
#+end_src
** Varnish Configuration Language
VCL is a DSL for Varnish. Used mainly with Reverb to update their fastly configs.
#+begin_src elisp
  ;; (use-package vcl-mode)
#+end_src
** Groovy
Man, sometimes you want to write java but without all the icky boilerplate. I encounter this when it is used with jenkins.
#+begin_src elisp
  (use-package groovy-mode
    :mode "\\.Jenkinsfile\\'"
    )
#+end_src
** Python
In order to better support python projects, it's helpful to have [[https://github.com/jorgenschaefer/pyvenv][pyvenv]]
#+begin_src elisp
  (use-package pyvenv :commands pyvenv-activate)
#+end_src
** [[https://github.com/json-emacs/json-mode][JSON mode]]
Better than using js-mode which gets cranky fast.
#+begin_src elisp
  (use-package json-mode
    :mode "\\.json\\'")
#+end_src
** [[https://github.com/tminor/jsonnet-mode][JSONNET mode]]
It's a programming language that emits JSON.
#+begin_src elisp
  (use-package jsonnet-mode
    :mode "\\.\\(lib|j\\)sonnet\\'")
#+end_src


* Org Mode
  :PROPERTIES:
  :header-args: :noweb-ref org-mode
  :END:
  Emacs org mode is a fantastic way to organize oneself. I've been
  using it for over a year and want to deepen my investment in org
  mode and org roam.
** Org
   So org is built into emacs, but the version that is included with
   gnu emacs is somewhat old.

   #+begin_src elisp :noweb yes :no-export yes
     (use-package org
       :diminish
       :bind (("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c c" . org-capture))
       :custom
       (org-export-backends '(ascii latex html md))
       <<org-custom>>
       :config
       <<org-config>>
     )
   #+end_src

   Org-indent mode indents org documents based on the heirarchical
   depth.

   #+begin_src elisp
     (use-package org-indent
       :straight org
       :hook (org-mode . org-indent-mode))
   #+end_src

   Visual line mode is also helpful when reading documents. It causes
   lines to wrap around at the edge of the frame, and the editing
   commands operate on visual lines, not logical lines.

   #+begin_src elisp
     (use-package simple
       :straight nil
       :hook (org-mode . visual-line-mode))
   #+end_src

   Finally, mixed-pitch mode modifies the buffer such that lines can
   have fonts of varying pitch, which helps with readability and makes
   Org look better.
   #+begin_src elisp
     (use-package mixed-pitch
       :hook (org-mode . mixed-pitch-mode))
   #+end_src
*** Org Customization
    :PROPERTIES:
    :header-args: :noweb-ref org-custom
    :END:
    Org looks nicer when italicized, bold, links and other things are
    formatted and prettified.
    #+begin_src elisp
      (org-hide-emphasis-markers t)
      (org-pretty-entities t)
      (org-export-use-babel nil)
    #+end_src

    For a while I was doing math notes and embedding latex in my
    org. That was cool, and I ended up doing this arcane stuff to make
    my rendered latex snippets look awesome.

    #+begin_src elisp
      (org-format-latex-options '(:foreground default :background default :scale 2 :html-foreground "Black" :html-background "Transparent" :html-scale 2 :matchers
					      ("begin" "$1" "$" "$$" "\\(" "\\[")))
    #+end_src

    And for my org agenda, we'll keep those files in =~/Documents/org/agenda=, but we'll also capture todos from =~/Documents/org/journal=
    #+begin_src elisp
      (org-agenda-files '("~/Documents/org/agenda/" "~/Documents/org/journal/"))
    #+end_src
*** Org-Babel
:PROPERTIES:
:header-args: :noweb-ref org-config
:END:
    Let's activate ditaa drawings in org
    #+begin_src elisp :noweb yes :no-export yes
      (org-babel-do-load-languages
       'org-babel-load-languages
       '(
         (ditaa . t)
         (shell . t)
         <<org-babel-load-languages>>
         ))
    #+end_src

    And make org babel stop asking to confirm code eval
    #+begin_src elisp :noweb-ref org-custom
      (org-confirm-babel-evaluate nil)
    #+end_src
** Beamer Presentations
Why use powerpoint or something for presentations when you can do all of it in org?
Reference: [[https://github.com/fniessen/refcard-org-beamer]]

#+begin_src elisp
  (use-package ox-latex
    :straight org ;; Part of the Org package
    :custom (org-latex-listings t)
    :config
    (add-to-list 'org-latex-classes
                 `("beamer"
                   ,(concat "\\documentclass[presentation]{beamer}\n"
                            "[DEFAULT-PACKAGES]"
                            "[PACKAGES]"
                            "[EXTRA]\n")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src
*** Authoring Presentations
The title page will have the following elements from document
keywords. Org adds the comma in the front to keep the example from mixing
up the parsing.
#+begin_example
  ,#+TITLE: Document title
  ,#+AUTHOR: Carl Thuringer
  ,#+DATE: 2021-3-24
#+end_example
** Org Roam
The second part of the ultimate org setup, a hypertext database of
project notes. That's [[https://www.orgroam.com/][org-roam]].

#+begin_src elisp
  (use-package org-roam
    :diminish
    :ensure t
    :preface
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename "~/Documents/org/roam"))
    (org-roam-index-file "~/Documents/org/roam/index.org")
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
    :config
    (org-roam-setup))
#+end_src
** Org Journal
One thing I've noticed with using =org-roam-dailies= is that I create a bunch of daily journal entries but then never revisit them. In fact it's not very useful for just capturing how I'm feeling or browsing back through the days. I found myself starting to link to other roam documents from the journal, and even then didn't find it super useful to check the daily backlinks. Really I want my journal to be browseable, and so I think the best way to represent the journal is in a continuous text file.

Therefore I happened upon [[https://github.com/bastibe/org-journal][org-journal]], which seems to do exactly what I want.

I will configure org-journal to place my journals in =~/org/journal=, and use a yearly file format.
#+begin_src elisp :noweb yes :no-export yes
  (use-package org-journal
    :demand t
    :commands (org-journal-new-entry)
    :bind ("C-c c" . org-journal-new-entry)
    :custom
    (org-journal-dir "~/Documents/org/journal")
    (org-journal-file-type 'yearly)
    (org-journal-file-format "%Y.org")
    (org-journal-date-format "%A, %Y-%m-%d")
    :preface
    <<org-journal-preface>>
    :bind
    <<org-journal-bind>>
    )
#+end_src
*** Close Org Journal when I save the entry (like org-capture)
This is a neat snippet found on the github page for org-journal:
#+begin_src elisp :noweb-ref org-journal-preface
  (defun crt/org-journal-save-entry-and-exit()
    "Simple convenience function.
    Saves the buffer of the current day's entry and kills the window
    Similar to org-capture like behavior"
    (interactive)
    (save-buffer)
    (kill-buffer-and-window))
#+end_src

#+begin_src elisp :noweb-ref org-journal-bind
  (:map org-journal-mode-map
        ("C-x C-s" . crt/org-journal-save-entry-and-exit))
#+end_src
** Latex
It's helpful to embed latex formulas sometimes when writing in org
#+begin_src elisp
  (use-package cdlatex)
  (use-package auctex)
  (use-package company-auctex)
#+end_src
** Gnuplot
Lets us do something cool with org tables: Plot them in gnuplot
#+begin_example
  ,#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
  | Sede      | Max cites | H-index |
  |-----------+-----------+---------|
  | Chile     |    257.72 |   21.39 |
  | Leeds     |    165.77 |   19.68 |
  | Sao Paolo |     71.00 |   11.50 |
  | Stockholm |    134.19 |   14.33 |
  | Morelia   |    257.56 |   17.67 |
#+end_example

#+begin_src elisp
  (use-package gnuplot)
  (use-package gnuplot-mode)
#+end_src

And let's also enable org-babel plotting.
#+begin_src elisp :noweb-ref org-babel-load-languages
  (gnuplot . t)
#+end_src
* Docker
:PROPERTIES:
:header-args: :noweb-ref docker
:END:
I often work inside docker containers, either on my personal devices
or on work devices. When I'm doing such, I end up in a tricky
situation where I cannot seamlessly operate the development
environment in emacs because, for example, the database is only
exposed in docker and I cannot run ruby tests without the database.

** Tramp
I tried using some docker-tramp elisp directly but it wasn't working,
so I checked jwiegley's init and borrowed what he's doing there.
#+begin_src elisp
  (use-package docker-tramp
    :custom
    (docker-tramp-use-names t))
  (use-package counsel-tramp :commands counsel-tramp)
  (use-package tramp :straight nil
    :config
    ;; jww (2018-02-20): Without this change, tramp ends up sending hundreds of
    ;; shell commands to the remote side to ask what the temporary directory is.
    (put 'temporary-file-directory 'standard-value '("/tmp"))
    (setq tramp-auto-save-directory "~/.cache/emacs/backups"
          tramp-persistency-file-name "~/.emacs.d/data/tramp")
    )

#+end_src

* Ledger
:PROPERTIES:
:header-args: :noweb-ref ledger
:END:
Plain Text Accounting with https://www.ledger-cli.org
#+begin_src elisp
  (use-package ledger-mode
    :custom
    (ledger-reports
     '(("bal -V" "ledger ")
       ("bal" "%(binary) -f %(ledger-file) bal")
       ("reg" "%(binary) -f %(ledger-file) reg")
       ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
       ("account" "%(binary) -f %(ledger-file) reg %(account)")))
  
    )
  (use-package flycheck-ledger
    :after (flycheck ledger-mode)
    :hook (ledger-mode . flycheck-mode)
    )
#+end_src
* Documentation
  :PROPERTIES:
  :header-args: :noweb-ref documentation
  :END:
** PlantUML Mode
   https://plantuml.com/ is a gross-looking but powerful language for
   markup. Lately it has become a lot less gross but the website is
   still stuffed with ads.

   #+begin_src elisp
     (use-package plantuml-mode
       :magic ("%PUML" . plantuml-mode)
       )
   #+end_src
* Database
:PROPERTIES:
:header-args: :noweb-ref database
:END:
Emacs has built in modes for talking to databases through psql!
** sql-postgres
Add the port parameter to the list of things that it checks for
#+begin_src elisp
  (use-package sql
    :straight nil
    :config
    (add-to-list 'sql-postgres-login-params 'port t))
#+end_src

And also enable sql for org-babel
#+begin_src elisp :noweb-ref org-babel-load-languages
  (sql . t)
#+end_src
* Kubernetes
:PROPERTIES:
:header-args: :noweb-ref kubernetes
:END:
It's a neat thing! Ok, let's try using this kubernetes porcelain
#+begin_src elisp
    (use-package kubernetes
      :commands (kubernetes-overview)
      :custom
      kubernetes-poll-frequency 3600
      kubernetes-redraw-frequency 3600)
#+end_src
